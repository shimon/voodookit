{% extends 'vkit_base.html' %}
{% load exampletool %}

{% block subtitle %}Demos{% endblock %}

{% block maincontent %}
<h1 class="notopmargin">{% include '_myname_voodookit.html' %}: Test Suite</h1>


<h2 class="exp">A Better &lt;table&gt;</h2>

{% example "ex1" %}

At its simplest, Voodookit will silently process a table of data:

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Item</th> <th>Quantity</th> </tr>
      <tr> <td>Table</td> <td>1.0</td> </tr>
      <tr> <td>Chair</td> <td>4.0</td> </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo();
    {% endjscode %}

    {% clicktorun %}vk{{eid}}.col(1).sort(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(1).sortReverse(){% endclicktorun %}


    {% doctest %}
      {% code %}vk{{eid}}.numRows(){% endcode %}
      {% expect %}3{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}.numCols(){% endcode %}
      {% expect %}2{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}.numContentRows(){% endcode %}
      {% expect %}2{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}.numHeaderRows(){% endcode %}
      {% expect %}1{% endexpect %}
    {% enddoctest %}

    <p>In addition to getting general information about the table, you can
    query for a specific cell by (row, col) position.  Position coordinates
    are 0-indexed from the top left, and non-content rows are skipped.  The
    return value is an instance of VkCell.</p>

    {% doctest %}
      {% code %}vk{{eid}}.cell(0,1).value(){% endcode %}
      {% expect %}"1.0"{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}.cell(0,1).toString(){% endcode %}
      {% expect %}"1.0"{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}.cell(1,0){% endcode %}
      {% expect %}"Chair"{% endexpect %}
    {% enddoctest %}

    <p> If you want to handle an entire column at once, you can request it by index:
    </p>

    {% doctest %}
      {% code %}vk{{eid}}.col(1).cellValues().join(", "){% endcode %}
      {% expect %}"1.0, 4.0"{% endexpect %}
    {% enddoctest %}

    <p>
      You can even calculate aggregate values for a column using the <tt>reduce</tt> function:
    </p>

    {% doctest %}
      {% code %}vk{{eid}}.col(1).reduce( function(x,y) { return parseFloat(x)+parseFloat(y); } ){% endcode %}
      {% expect %}5.0{% endexpect %}
    {% enddoctest %}

    <p>Or find matching cells using the <tt>grep</tt> function, which returns an array of VkCells for which the test function returns a true value:</p>

    {% doctest %}
      {% code %}vk{{eid}}.col(0).grep( function(vkcell) { return vkcell.value()=="Chair"; } )[0].row().cell(1){% endcode %}
      {% expect %}4.0{% endexpect %}
    {% enddoctest %}

    
    <p>Finally, you can also get Voodookit objects based on a new or already-Voodookit-enabled <tt>&lt;table&gt;</tt> element, or from <tt>tr</tt> or <tt>td</tt> elements within such a table:</p>

    {% doctest %}
      {% code %}$("#{{eid}}").voodoo().constructor.name{% endcode %}
      {% expect %}"VkTable"{% endexpect %}
    {% enddoctest %}
    
    {% doctest %}
      {% code %}$("#{{eid}} tr:last").voodoo().constructor.name{% endcode %}
      {% expect %}"VkRow"{% endexpect %}
    {% enddoctest %}
    
    {% doctest %}
      {% code %}$("#{{eid}} tr:last td:first").voodoo().constructor.name{% endcode %}
      {% expect %}"VkCell"{% endexpect %}
    {% enddoctest %}
    
    
    
{% endexample %}


<h2 class="exp">Row Addressing</h2>

{% example "ex1a" %}
You can also look up values by row; a <tt>VkRow</tt> object exists for each
row in your table, and can be used to look up a cell's neighbors.


    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Item</th>  <th>Price</th>   </tr>
      <tr> <td>Table</td> <td>100</td>     </tr>
      <tr> <td>Chair</td> <td>20.00</td>   </tr>
      <tr> <td>Sofa</td>  <td>1200.00</td> </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            { name: "item" },
            { name: "price" }
        ]
    });
    {% endjscode %}

    {% doctest %}
      {% code %}vk{{eid}}.cell(1, 0).row().cell("price"){% endcode %}
      {% expect %}20.00{% endexpect %}
    {% enddoctest %}

    Similarly, you can get a cell's column, and query for another row's value in the same column:

    {% doctest %}
      {% code %}vk{{eid}}.cell(1, 0).col().cell(0){% endcode %}
      {% expect %}"Table"{% endexpect %}
    {% enddoctest %}

    or start with a row lookup:

    {% doctest %}
      {% code %}vk{{eid}}.row(1).cell("item"){% endcode %}
      {% expect %}"Chair"{% endexpect %}
    {% enddoctest %}


{% endexample %}
  


<h2 class="exp">Column Data Types</h2>

{% example "ex2" %}

Voodookit's default sorting works fine for alphabetical data. But what if you've got a bunch of actual floating-point numbers?

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Item</th>  <th>Price</th>   </tr>
      <tr> <td>Table</td> <td>100</td>     </tr>
      <tr> <td>Chair</td> <td>20.00</td>   </tr>
      <tr> <td>Sofa</td>  <td>1200.00</td> </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo();
    {% endjscode %}

    {% clicktorun %}vk{{eid}}.col(1).sort(){% endclicktorun %}

    <p>As you can see, this doesn't work so well.  We need to tell Voodookit that the second column contains floating-point numbers.</p>

{% endexample %}

<h2 class="exp">Column Data Types: Floating-point Numbers</h2>

{% example "ex3" %}

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Item</th>  <th>Price</th>   </tr>
      <tr> <td>Table</td> <td>100</td>     </tr>
      <tr> <td>Chair</td> <td>20.00</td>   </tr>
      <tr> <td>Sofa</td>  <td>1200.00</td> </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            { type: $.voodoo.types.string }, // default
            { type: $.voodoo.types.float }
        ]
    });
    {% endjscode %}

    {% clicktorun %}vk{{eid}}.col(1).sort(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(1).sortReverse(){% endclicktorun %}

    <p>Here we're passing a little bit of information to Voodookit about the columns in our table. The <tt>$.voodoo.types.float</tt> object is a Voodookit column type, whose main purpose is to provide a <tt>parseValue</tt> method, converting the table cell's HTML contents into a Javascript value.  For this type, the parseValue method is simply a call to Javascript's built-in <tt>parseFloat</tt> function.</p>

    <p> Declaring types ensures that any cell's <tt>value()</tt> function
      returns a Javascript object of the appropriate type.  It also lets you use the type-correct operators for things like arithmetic, and the convenient built-in column arithmetic function:</p>

    {% doctest %}
      {% code %}vk{{eid}}.col(1).sum(){% endcode %}
      {% expect %}1320.00{% endexpect %}
    {% enddoctest %}


{% endexample %}

<h2 class="exp">Column Names</h2>

{% example "ex3a" %}

You can also give columns alphanumeric names, and refer to them using these
names instead of their integer identifiers.


    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Item</th>  <th>Price</th>   </tr>
      <tr> <td>Table</td> <td>100</td>     </tr>
      <tr> <td>Chair</td> <td>20.00</td>   </tr>
      <tr> <td>Sofa</td>  <td>1200.00</td> </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            { name: "item" },
            { name: "price",
              type: $.voodoo.types.float }
        ]
    });
    {% endjscode %}

    {% doctest %}
      {% code %}vk{{eid}}.col("price").reduce( function(x,y) { return parseFloat(x)+parseFloat(y); } ){% endcode %}
      {% expect %}1320.0{% endexpect %}
    {% enddoctest %}

    {% clicktorun %}vk{{eid}}.col("price").sort(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col("price").sortReverse(){% endclicktorun %}

    As an added bonus, when you provide a column name, Voodookit adds that
    name as a class to all <tt>td</tt> elements in that column:

    
    {% doctest %}
       {% code %}$("#{{eid}} tr:eq(2) td:eq(1)").hasClass("price"){% endcode %}
       {% expect %}true{% endexpect %}
    {% enddoctest %}

{% endexample %}


<h2 class="exp">Convenience Method for Sorting</h2>

{% example "ex3b" %}

    We often want to allow users to sort the content of a table by clicking
    on <tt>th</tt> elements in the first row.  Voodookit provides a
    convenience method, <tt>makeHeadersSort()</tt>, which easily activates
    this behavior.

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th> <th>Age</th> <th>IQ</th> </tr>
      <tr> <td>Alice</td> <td>2</td> <td>100</td> </tr>
      <tr> <td>Bob</td> <td>1</td> <td>110</td> </tr>
      <tr> <td>Charlie</td> <td>3</td> <td>90</td> </tr>
    </table>

    <style>#{{eid}} th { cursor: pointer; }</style>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo();
    vk{{eid}}.makeHeadersSort();

    // synthesize a click event on the second th, so we can test that
    // the table has been sorted by age.
    $("#{{eid}} tr:first th:eq(1)").trigger("click");
    {% endjscode %}

    {% doctest %}
       {% code %} vk{{eid}}.cell(1,1).value() {% endcode %}
       {% expect %}2{% endexpect %}
    {% enddoctest %}

{% endexample %}



<h2 class="exp">Date and Time Data</h2>

{% example "ex4" %}

Voodookit also supports date and date+time data types: <tt>DateTime</tt>,
for a date and time, and <tt>Date</tt>, which is a date only.  One way to
express the values for cells of these types is in milliseconds since epoch.
An advantage of this approach is that times can be localized on the client
side, so you don't have to care what time zone your user is in.

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Task</th>                          <th>Deadline (raw)</th> <th>Deadline (date)</th> <th>Deadline (d+t)</th></tr>
      <tr> <td>(3) get approval from client</td>  <td>1245729600000</td>  <td>1245729600000</td>   <td>1245729600000</td> </tr>
      <tr> <td>(1) sketch UI for floobulator</td> <td>1239163200000</td>  <td>1239163200000</td>   <td>1239163200000</td> </tr>
      <tr> <td>(2) send example links to Tim</td> <td>1239336009000</td>  <td>1239336009000</td>   <td>1239336009000</td> </tr>
      <tr> <td>(4) watch a bunch of TV</td>       <td></td>               <td></td>                <td></td>              </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
            cols: [
            { },
            { },
            { type: $.voodoo.types.date },
            { type: $.voodoo.types.dateTime }
        ]
});

    vk{{eid}}.col(2).sort();
    {% endjscode %}

    {% doctest %}
       {% code %} vk{{eid}}.cell(0,2).value().constructor == Date{% endcode %}
       {% expect %}true{% endexpect %}
    {% enddoctest %}

    {% doctest %}
       {% code %} vk{{eid}}.cell(0,2).value().getTime() < vk{{eid}}.cell(1,2).value().getTime() {% endcode %}
       {% expect %}true{% endexpect %}
    {% enddoctest %}

    {% doctest %}
       {% code %} vk{{eid}}.cell(1,2).value().getTime() < vk{{eid}}.cell(2,2).value().getTime() {% endcode %}
       {% expect %}true{% endexpect %}
    {% enddoctest %}

    {% doctest %}
       {% code %} vk{{eid}}.cell(0,2).value().getTime() < vk{{eid}}.cell(2,2).value().getTime() {% endcode %}
       {% expect %}true{% endexpect %}
    {% enddoctest %}


    {% clicktorun %}vk{{eid}}.col(2).sort(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(2).sortReverse(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(2).sortReverseBlanksLast(){% endclicktorun %}

{% endexample %}



<h2 class="exp">Events</h2>

{% example "ex5" %}

Want to add an <tt>odd</tt> class to the odd rows? Or respond to changes in
the table's sort order?  Voodookit generates events you can register for:
<ul>

  <li><b><tt>vkRowScan</tt></b> &mdash; generated when a content row (a
  <tt>tr</tt> element that contains one or more <tt>td</tt> elements) is
  handled by Voo2do: on first review of the table content, and on subsequent
  changes to row position (sorting).  The event originates from the row
  <tt>tr</tt> element.  In this event's <tt>data</tt> hash: <ul>

      <li><tt>rowIndex</tt>: an integer indicating this row's position among
      all content rows in the table, starting from 0.</li>

      <li><tt>vkRow</tt>: the VkRow object for this table row.</li>

    </ul>
  </li>

  <li><b><tt>vkChange</tt></b> &mdash; generated when the value of a cell is
  changed.  The event originates from the changed <tt>td</tt> element, and
  bubbles up the document so you can also bind to a <tt>table</tt> and get
  this event.  Because you may be interested in changes within a column, the
  <tt>vkChange</tt> event is also fired by the corresponding column, which
  provides a <tt>bind</tt> method for this purpose. In this event's
  <tt>data</tt> hash: <ul> <li><tt>oldValue</tt>: the cell's previous
  value.</li>  <li><tt>cell</tt>: the VkCell object for the affected cell.
  You can get the current (new) value by calling <tt>cell.value()</tt>.</li>
  </ul> </li>


  <li><b><tt>vkRowAppend</tt></b> &mdash; generated when a new row is added
  to the table <i>after</i> the table's initial loading, e.g. with
  <tt>append</tt> or <tt>appendRow</tt>.  Originates with the new
  <tt>tr</tt> element and bubbles up.</li>

  <li><b><tt>vkRowDelete</tt></b> &mdash; generated before a row is deleted
  from the table using the <tt>deleterow()</tt> method.  Originates with the
  delete <tt>tr</tt> element and bubbles up.  Note that deleting a row will
  also trigger <tt>vkRowScan</tt> events to be triggered for all
  <i>remaining</i> rows; these are triggered after the <tt>vkRowDelete</tt>
  event.</li>

  <li><b><tt>vkRowsReordered</tt></b> &mdash; generated once after a table's
  rows have been re-ordered, such as in a sort operation. Originates on the
  <tt>table</tt> object.</li>

</ul>

These events are triggered on the underlying <tt>tr</tt> elements, so you
can listen for and react to them in the typical jQuery way.

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>First Name</th>  <th>Last Name</th> </tr>
      <tr> <td>Bob</td>         <td>Jones</td>     </tr>
      <tr> <td>Alice</td>       <td>Smith</td>     </tr>
      <tr> <td>Charlie</td>     <td>Williams</td>  </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    // we use the live() event delegation system so that even events on
    // newly-created rows trigger the handler.
    $("#{{eid}} tr").live("vkRowScan", function(e, data) {
        var isOdd = data["rowIndex"] % 2;
        $(this).css({ "background-color": isOdd? "skyblue": "lightgreen",
                      "font-weight": isOdd? "bold": "normal"
                    });
    });
    var vk{{eid}} = $("#{{eid}}").voodoo();

    var vk{{eid}}_got_rowAppend = 0;
    var vk{{eid}}_got_rowsReordered = 0;
    $("#{{eid}}").bind("vkRowAppend", function() {
        vk{{eid}}_got_rowAppend += 1;
    });
    $("#{{eid}}").bind("vkRowsReordered", function() {
        vk{{eid}}_got_rowsReordered += 1;
    });
    vk{{eid}}.appendRow(["Dave","Sawyer"]);
    vk{{eid}}.col(1).sort();
    {% endjscode %}

    {% clicktorun %}vk{{eid}}.col(0).sort(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(1).sort(){% endclicktorun %}

    {% doctest %}
      {% code %}$("#{{eid}} tr:eq(2)").css("font-weight"){% endcode %}
      {% expect %}"bold"{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}_got_rowAppend{% endcode %}
      {% expect %}1{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}_got_rowsReordered{% endcode %}
      {% expect %}1{% endexpect %}
    {% enddoctest %}
{% endexample %}



<h2 class="exp">Renderers</h2>



{% example "ex6" %}

<p>In the examples so far, the values displayed in our HTML tables have
simply been the default, stringified version of the cell's value.  For a
<tt>$.voodoo.types.date</tt> column, we see something like "06/23/2009".
But what if you want your cell displayed in different format?</p>

<p>That's where <b>renderers</b> come in.  Renderers determine how to
display the values of cells in HTML.  The renderer has access to the cell's
<tt>VkCell</tt> object, allowing the rendering behavior to be based on the
cell's value as well as its row, column, and table.</p>

<p>Voodookit includes the following built-in renderers. <b>These are classes
and should be instantiated using <tt>new</tt>.</b> You can also build
your own renderer&mdash;more on that later.</p>

<ul>
  <li><tt>$.voodoo.render.<b>String</b></tt></li>
  <li><tt>$.voodoo.render.<b>HtmlString</b></tt></li>
  <li><tt>$.voodoo.render.<b>FloatHours</b> *TODO*</tt></li>
  <li><tt>$.voodoo.render.<b>Currency</b> *TODO*</tt></li>
  <li><tt>$.voodoo.render.<b>LocaleDate</b></tt></li>
  <li><tt>$.voodoo.render.<b>LocateDateTime</b></tt></li>
</ul>

<p>Many of these renderers accept options that configure how they
behave. Options can be passed in as an associative array parameter.  Two
options are supported by all renderers: <tt>default</tt>, which specifies
the result to return when rendering an empty cell, and <tt>defaultValue</tt>
which does something slightly different: it treats empty cells as having the
given value &mdash; useful if you want to apply the same logic to generate the HTML for empty cells.</p>

<p><b>Note:</b> The word <tt>default</tt> is a reserved word in
Javascript. This option should probably be renamed; in any usage, be sure to
quote the word <tt>default</tt>.  For example, the object literal <tt>{
default: "none" }</tt> will work in Firefox but cause a syntax error in
Google Chrome, whereas <tt>{ "default": "none" }</tt> works in all
browsers.</p>

Let's see how the <tt>default</tt> setting works using the String renderer.

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th>    <th>Pizza Choices</th> </tr>
      <tr> <td>Bob</td>     <td>Pepperoni</td>     </tr>
      <tr> <td>Alice</td>   <td> </td>             </tr>
      <tr> <td>Charlie</td> <td></td>              </tr>
    </table>

    <p>Part 2:</p>

    <table id="{{eid}}_2">
      <tr> <th>Name</th>    <th>Pizza Choices</th> </tr>
      <tr> <td>David</td>   <td></td>              </tr>
      <tr> <td>Eliza</td>   <td><b>peppers</b>--this is bad, should just be HTML</td>              </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            {},
            { render: new $.voodoo.render.String({"default":"<i>unknown</i>"}) }
        ]
    });

    // on the second table, let's use the defaultValue option instead:
    var vk{{eid}}_2 = $("#{{eid}}_2").voodoo({
        cols: [
            {},
            { render: new $.voodoo.render.String({"defaultValue":"<i>unknown</i>"}) }
        ]
    });
    {% endjscode %}

    {% doctest %}
      {% code %}$("#{{eid}} tr:last td:last").html(){% endcode %}
      {% expect %}"<i>unknown</i>"{% endexpect %}
    {% enddoctest %}

    Note that in our HTML, the value for Alice's pizza choices is a single
    space character&mdash; not considered empty by Voodookit. Hence it is
    rendered as a space:

    {% doctest %}
      {% code %}"["+$("#{{eid}} tr:eq(2) td:last").html()+"]"{% endcode %}
      {% expect %}"[ ]"{% endexpect %}
    {% enddoctest %}

    In the second table, we used the <tt>defaultValue</tt> option instead of
    <tt>default</tt>.  What does this mean?

    {% doctest %}
      {% code %}$("#{{eid}}_2 tr:eq(1) td:last").html(){% endcode %}
      {% expect %}"&lt;i&gt;unknown&lt;/i&gt;"{% endexpect %}
    {% enddoctest %}

    {% comment %}
      {% clicktorun %}$("#{{eid}}_2 tr:eq(2) td:last").html(){% endclicktorun %}
      {% clicktorun %}$("#{{eid}}_2 tr:eq(2) td:last").text(){% endclicktorun %}
    {% endcomment %}

{% endexample %}


<h2 class="exp">Renderers with Editing</h2>

{% example "ex7" %}

Often, you'll want to let users not only view the data in a table cell,
but also edit that data.  Voodookit's editable renderers make this easy,
by providing a representation of the cell value as an editable HTML form
widget, whose <tt>change</tt> event triggers a value change on the
corresponding <tt>vkCell</tt>.  That means the changes are more than
just skin deep&mdash;you can instantly re-sort, or use event listeners
to react to <tt>vkValueChange</tt> events.


    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th>    <th>Pizza Choices</th> <th>Paid?</th> </tr>
      <tr> <td>Alice</td>   <td>Artichokes</td>    <td>1</td>  </tr>
      <tr> <td>Bob</td>     <td>Pepperoni</td>     <td>0</td> </tr>
      <tr> <td>Charlie</td> <td></td>              <td></td>      </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            {},
            { render: new $.voodoo.render.TextField() },
            { type: $.voodoo.types.boolean,
              render: new $.voodoo.render.CheckboxField() }
        ]
    });
    {% endjscode %}

    {% clicktorun %}vk{{eid}}.col(0).sort(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(0).sortReverse(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(1).sort(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(1).sortReverse(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(2).sort(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(2).sortReverse(){% endclicktorun %}

{% endexample %}

<h2 class="exp">Dealing with Edits</h2>

{% example "ex8" %}

    When a cell's value is changed, the vkChange event fires. This event
    bubbles up from the changed <tt>td</tt> element, so you can listen for
    it on a particular cell or on the whole table.

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th>    <th>Pizza Choices</th> <th>Slices Eaten</th> </tr>
      <tr> <td>Alice</td>   <td>Artichokes</td>    <td>1</td>  </tr>
      <tr> <td>Bob</td>     <td>Pepperoni</td>     <td>0</td> </tr>
      <tr> <td>Charlie</td> <td></td>              <td>0</td>      </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            {},
            { render: new $.voodoo.render.TextField(),
              name: "pizza_choices"
            },
            { type: $.voodoo.types.integer,
              name: "numslices",
              render: new $.voodoo.render.TextField() }
        ]
    });

    var vk{{eid}}_gotTableEvent = false;
    var vk{{eid}}_gotRowEvent = false;
    var vk{{eid}}_gotColumnEvent = false;

    $("#{{eid}}").bind("vkChange", function() {
        vk{{eid}}_gotTableEvent = true;
    });

    $("#{{eid}} tr:eq(2)").bind("vkChange", function() {
        vk{{eid}}_gotRowEvent = true;
    });

    vk{{eid}}.col("pizza_choices").bind("vkChange", function() {
        vk{{eid}}_gotColumnEvent = true;
    });

    vk{{eid}}.cell(1,1).value("Sausage");
    {% endjscode %}

    {% doctest %}
      {% code %}vk{{eid}}_gotTableEvent{% endcode %}
      {% expect %}true{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}_gotRowEvent{% endcode %}
      {% expect %}true{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}_gotColumnEvent{% endcode %}
      {% expect %}true{% endexpect %}
    {% enddoctest %}

    <p>The vkChange event is also used by renderers to update the rendered
    value when a cell's value is changed; try this increment operation to
    see how that works:</p>

    {% clicktorun %}vk{{eid}}.cell(1,2).value( 1+vk{{eid}}.cell(1,2).value() ){% endclicktorun %}

{% endexample %}



<h2 class="exp">Adding Rows</h2>

{% example "ex9" %}

 In addition to changing data in existing rows, you can add rows to a
 Voodookit-enabled table.  You can do this in two ways:

 <ol>

   <li>use a standard jQuery method on the table, like
   <tt>$("#mytable").append("<tr><td>...</td></tr>")</tt> followed by a call
   to <tt>$("#mytable").voodoo.findNewRows()</tt>, or</li>

   <li>use the built-in <tt>$("#mytable").voodoo.append()</tt> method, which
   does the same thing.</li>

 </ol>

 When content is added this way, any new rows are processed and rendered
 based on the parameters first sent to Voodookit on initialization of the
 parent table. A <tt>vkRowScan</tt> event is also generated for each new row.

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th>    <th>Pizza Choices</th> <th>Slices Eaten</th> </tr>
      <tr> <td>Alice</td>   <td>Artichokes</td>    <td>1</td>  </tr>
      <tr> <td>Bob</td>     <td>Pepperoni</td>     <td>0</td> </tr>
      <tr> <td>Charlie</td> <td>Chicken</td>       <td>0</td>      </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}}_newRowText = null;
    var vk{{eid}}_newRowIndex = null;

    $("#{{eid}}").bind("vkRowScan", function(e,data) {
        vk{{eid}}_newRowText = data.vkRow.cell(0).value().toString();
        vk{{eid}}_newRowIndex = data.rowIndex;
    });

    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            {},
            { render: new $.voodoo.render.TextField() },
            { render: new $.voodoo.render.TextField() }
        ]
    });

    $("#{{eid}}").voodoo().append("<tr><td>Dave</td><td>Olives</td><td>1</td></tr>");
    {% endjscode %}


    {% doctest %}
      {% code %}vk{{eid}}_newRowIndex{% endcode %}
      {% expect %}3{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}_newRowText{% endcode %}
      {% expect %}"Dave"{% endexpect %}
    {% enddoctest %}

    So to recap, there's the two-step method: add table content however you want and then call <tt>findNewRows</tt>:

    {% clicktorun %}$("#{{eid}}").append("<tr><td>Ed</td><td>Spinach</td><td>2</td></tr>"){% endclicktorun %}

    {% clicktorun %}$("#{{eid}}").voodoo().findNewRows(){% endclicktorun %}

    Or the <tt>append</tt> method built into Voodookit's <tt>VkTable</tt> class, which returns the <tt>VkTable</tt> object so it's chainable:

    {% clicktorun %}$("#{{eid}}").voodoo().append("<tr style=display:none><td>Ed</td><td>Spinach</td><td>2</td></tr>").$table.find("tr:last").fadeIn("slow") && false{% endclicktorun %}

{% endexample %}

<h2 class="exp">But there's a shortcut...</h2>

{% example "ex9b" %}

   Often, you just want to append a blank row, or a row with certain values
   pre-filled.  Voodookit provides a convenience method, <tt>appendRow</tt>,
   that does this based on its parameters:

   <ul>
       <li><i>no arguments</i>: appends a row with as many empty <tt>td</tt> elements as there are columns in the table so far.</li>

       <li><i>integer</i>: appends a row with as many empty <tt>td</tt> elements as specified in the parameter.</li>

       <li><b>COMING SOON BUT NOT YET...</b></li>

       <li><i>array</i>: appends a row with values as given in order in the parameter.</li>

       <li><i>object (hash)</i>: appends a row with as many columns as in the table so far, with some values filled in using column names or indices if available in the parameter.</li>

     </ul>
    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th>    <th>Pizza Choices</th> <th>Slices Eaten</th> </tr>
      <tr> <td>Alice</td>   <td>Artichokes</td>    <td>1</td>  </tr>
      <tr> <td>Bob</td>     <td>Pepperoni</td>     <td>0</td> </tr>
      <tr> <td>Charlie</td> <td>Chicken</td>       <td>0</td>      </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}}_newRowTexts = [];

    $("#{{eid}}").bind("vkRowScan", function(e,data) {
        vk{{eid}}_newRowTexts.push( data.vkRow.cell(0).value().toString() );
    });

    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            { name: "name" },
            { render: new $.voodoo.render.TextField(), name: "pizza_choices" },
            { render: new $.voodoo.render.TextField(), name: "num_slices" }
        ]
    });

    $("#{{eid}}").voodoo().appendRow();
    $("#{{eid}}").voodoo().appendRow(3);
    $("#{{eid}}").voodoo().appendRow(["Eustace", "Broccoli", 2]);
    {% endjscode %}

    {% doctest %} {# this test MUST be first here; others use its result #}
      {% code %}$("#{{eid}}").voodoo().appendRow({ name: "Frank", 2: 7 }).is("tr");{% endcode %}
      {% expect %}true{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}_newRowTexts[3]{% endcode %}
      {% expect %}""{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}_newRowTexts[4]{% endcode %}
      {% expect %}""{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}_newRowTexts[5]{% endcode %}
      {% expect %}"Eustace"{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}_newRowTexts[6]{% endcode %}
      {% expect %}"Frank"{% endexpect %}
    {% enddoctest %}

    One more thing: the <tt>appendRow</tt> returns a jQuery object for the
    row, so you can do further manipulation of the row if you wish:
    
    {% clicktorun %}
    $("#{{eid}}").voodoo().appendRow().find("input:first").focus() && false;
    {% endclicktorun %}


{% endexample %}






<h2 class="exp">Deleting Rows</h2>

{% example "ex10" %}

  <p>Add too many rows? Maybe you want to delete some. You can do this with
  standard jQuery/DOM methods if you wish: just <tt>.remove()</tt> a
  <tt>tr</tt> and all VoodooKit methods (row counts, positional cell
  coordinates, etc.) will keep working just fine, because VoodooKit treats
  the DOM (plus jQuery <tt>.data</tt>) as the primary underlying data
  structure whenever possible.</p>

  <p>However, in most cases it is preferable to use the
  <tt>VkRow.deleterow()</tt> method, which will not only remove the appropriate
  <tt>tr</tt> from the table, but also generate some useful events:
  </p>
  
  <ul>
    <li><b><tt>vkRowDelete</tt></b> on the row about to be deleted, while the <tt>VkRow</tt> object is still accessible.</li>
    <li><b><tt>vkRowScan</tt></b> on all <i>remaining</i> rows in the table.</li>  </ul>


    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th>    <th>Slices Eaten</th>  <th>Delete?</th> </tr>
      <tr> <td>Alice</td>   <td>1</td>             <td></td>        </tr>
      <tr> <td>Bob</td>     <td>0</td>             <td></td>        </tr>
      <tr> <td>Charlie</td> <td>0</td>             <td></td>        </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}}_name_deleted;
    var vk{{eid}}_num_scans_per_name = {};

    $("#{{eid}}").bind("vkRowDelete", function(e) {
        vk{{eid}}_name_deleted = $(e.target).voodoo().cell(0);
    });

    $("#{{eid}} tr").bind("vkRowScan", function(e, data) {
        var r = data.vkRow;
        var name = r.cell(0).value();

        if(!vk{{eid}}_num_scans_per_name[ name ]) {
            vk{{eid}}_num_scans_per_name[ name ] = 0;
        }

        vk{{eid}}_num_scans_per_name[ name ]++;
    });

    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            {},
            { render: new $.voodoo.render.TextField() },
            { render: new $.voodoo.render.HtmlString({"default":"<a href='#' class='del'>del</a>"}) }
        ]
    });

    $("#{{eid}} a.del").live("click", function() {
        $(this).parents("tr").voodoo().deleterow();
        return false;
    });

    $("#{{eid}} a.del:first").trigger("click");
    {% endjscode %}

    {% doctest %}
      {% code %}vk{{eid}}.numContentRows(){% endcode %}
      {% expect %}2{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}_name_deleted{% endcode %}
      {% expect %}"Alice"{% endexpect %}
    {% enddoctest %}

    The row we deleted should have 1 row scan, from the initial load:

    {% doctest %}
      {% code %}vk{{eid}}_num_scans_per_name["Alice"]{% endcode %}
      {% expect %}1{% endexpect %}
    {% enddoctest %}

    Remaining rows should have 2 row scans, one from initial load and one
    after the deletion of the Alice row:

    {% doctest %}
      {% code %}vk{{eid}}_num_scans_per_name["Bob"]{% endcode %}
      {% expect %}2{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}_num_scans_per_name["Charlie"]{% endcode %}
      {% expect %}2{% endexpect %}
    {% enddoctest %}


    In some cases, you might not want to immediately remove the deleted
    <tt>tr</tt> from the document.  For example, you might want to animate
    the removal effect.  You can do this by calling <tt>prepToDelete</tt>
    instead of <tt>delete</tt>&mdash; <tt>prepToDelete</tt> will ready the
    row for deletion and send the appropriate events, and like
    <tt>delete</tt> will return a jQuery object wrapping the relevant
    <tt>tr</tt>.  But unlike <tt>delete</tt>, <tt>prepToDelete</tt> counts
    on you to make a final call to <tt>remove</tt> the row when you're done.
    (It is important that you actually do remove the row from its containing
    <tt>table</tt>; until you complete that step, the VkTable object's
    state, such as the result of <tt>numRows()</tt>, will be inconsistent
    with the events that have been generated.)

    {% clicktorun %}
    $("#{{eid}} tr:eq(1)").voodoo().prepDelete().fadeOut(function(){ $(this).remove(); }) && false;
    {% endclicktorun %}
    

{% endexample %}


<h2 class="exp">Computed Columns</h2>

{% example "ex11" %}

<p>
  Sometimes you want to calculate a value for a row. For example, if you
  are tracking tasks you might have <i>estimated time</i> and a <i>time
  elapsed</i> columns entered by the user. What if you want to also display
  a <i>time remaining</i> column?
</p>

<p>
  Voodookit makes this easy by letting you define a <b>computed
  column</b>.  Computed columns are like regular columns in your table, but
  instead of reading their value from the content of a <tt>&lt;td&gt;</tt>
  element, their value is calculated according to a formula you specify.
</p>

<p>
  Computed cell values can be based on any non-computed columns in the
  current row, as well arbitrary Javascript.  Values based on other columns
  will automatically change if their parameters are changed.  And of course,
  cells in computed columns still generate the same events as other
  cells.
</p>

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th>    <th>Slices Eaten</th>  <th>% of 8-slice Pizza</th> </tr>
      <tr> <td>Alice</td>   <td>1</td>             <td>?</td>        </tr>
      <tr> <td>Bob</td>     <td>0</td>             <td>.15</td>        </tr>
      <tr> <td>Charlie</td> <td>0</td>             <td></td>        </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            { name: "person" },
            { name: "num_slices",
              render: new $.voodoo.render.TextField(),
              type: $.voodoo.types.integer
            },
            { name: "pct_of_za",
              type: $.voodoo.types.float,
              compute_from_cols: [ "num_slices" ],
              compute_function: function(num_slices) {
                   return num_slices / 8;
              }
            },
        ]
    });
    {% endjscode %}

    {% doctest %}
      {% code %}vk{{eid}}.col("num_slices").is_computed(){% endcode %}
      {% expect %}false{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}.col("pct_of_za").is_computed(){% endcode %}
      {% expect %}true{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}.cell(0,2).value(){% endcode %}
      {% expect %}0.125{% endexpect %}
    {% enddoctest %}

    But wait, there's more! Computed columns listen for <tt>vkChange</tt>
    events on their neighbor cells specified in the
    <tt>compute_from_cols</tt> parameter.  So if we change one of the
    <tt>num_slices</tt> cells:

    {% doctest %}
      {% code %}vk{{eid}}.cell(1,1).value(3){% endcode %}
      {% expect %}3{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}.cell(1,2).value(){% endcode %}
      {% expect %}0.375{% endexpect %}
    {% enddoctest %}

    Try it yourself... just edit one of the central column values and watch
    the right column change in response!

{% endexample %}



<h2 class="exp">HTML Templating Renderers</h2>

{% example "ex12" %}

<p> 

  Sometimes it's simpler to specify how a column might look by writing an
  HTML template, instead of a renderer function.  Voodookit includes a
  simple template processor that, given a HTML-like template string,
  compiles a Renderer class that executes the given template.  The template
  can refer to other cells in the same row as variables, and can execute
  some basic javascript code.

</p>

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th>    <th>Slices Eaten</th>  <th>Story</th> </tr>
      <tr> <td>Alice</td>   <td>2</td>             <td></td>      </tr>
      <tr> <td>Bob</td>     <td>3</td>             <td></td>      </tr>
      <tr> <td>Charlie</td> <td>0</td>             <td></td>      </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            { name: "person" },
            { name: "num_slices",
              render: new $.voodoo.render.TextField(),
              type: $.voodoo.types.integer
            },
            { name: "story",
              render: $.voodoo.makeRen.template("<<person>> <<if num_slices>>ate <<num_slices>> slice(s).<<else>>is STARVING!<</if>>")
            },
        ]
    });
    {% endjscode %}


    {% doctest %}
      {% code %}vk{{eid}}.cell(0,2).$td.text(){% endcode %}
      {% expect %}"Alice ate 2 slice(s)."{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}.cell(2,2).$td.text(){% endcode %}
      {% expect %}"Charlie is STARVING!"{% endexpect %}
    {% enddoctest %}

    Note that currently, templates will only automatically re-render when
    their <i>cell's</i> value changes, but not when other values that may
    have been used in the template change.

{% endexample %}



<h2 class="exp">Alternate Representations of the Table Data</h2>

{% example "ex13" %}

<p>
  
  Voodookit includes a flexible facility to generate an alternate
  representation of the data in your table.  This allows you to take a
  VkTable in your document and, based on its current state including any
  recent user modifications, get a representation of that table.  You can
  use it to quickly get a JSON serialization of your table, or a custom
  representation specific to your needs.

</p>

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th>    <th>Slices Eaten</th> </tr>
      <tr> <td>Alice</td>   <td>2</td>            </tr>
      <tr> <td>Bob</td>     <td>3</td>            </tr>
      <tr> <td>Charlie</td> <td>0</td>            </tr>
    </table>

    <h4>Rendering output:</h4>
    <div style="background:linen; border: 1px solid blue;" id="{{eid}}_altrender"> </div>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            { name: "person",
              render: new $.voodoo.render.TextField() 
            },
            { name: "num_slices",
              render: new $.voodoo.render.TextField(),
              type: $.voodoo.types.integer
            }
        ]
    });
    {% endjscode %}

    {% clicktorun %}
    $("#{{eid}}_altrender").text(vk{{eid}}.altRender("json")) && false
    {% endclicktorun %}

    {% doctest %}
      {% code %}vk{{eid}}.altRender("json").indexOf("\"Charlie\",\"0\"") > 0{% endcode %}
      {% expect %}true{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}.altRender("json").charAt(0){% endcode %}
      {% expect %}"["{% endexpect %}
    {% enddoctest %}
  

{% endexample %}

<h2 class="exp">Custom AltRendering</h2>

{% example "ex14" %}
To create a custom rendering, you supply methods for the VkTable, VkRow,
VkColumn, and/or VkCell classes that return data in the desired format.  You can do this by directly adding methods to the classes:
<ul>
  <li><tt>$.voodoo.VkTable</tt></li>
  <li><tt>$.voodoo.VkColumn</tt></li>
  <li><tt>$.voodoo.VkRow</tt></li>
  <li><tt>$.voodoo.VkCell</tt></li>
</ul>

Here's an example where we'll write custom handlers to generate a printable HTML rendering of the table.

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th>    <th>Slices Eaten</th> </tr>
      <tr> <td>Alice</td>   <td>2</td>            </tr>
      <tr> <td>Bob</td>     <td>3</td>            </tr>
      <tr> <td>Charlie</td> <td>0</td>            </tr>
    </table>

    <h4>Rendering output:</h4>
    <div style="background:linen; border: 1px solid blue;" id="{{eid}}_altrender"> </div>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            { name: "person",
              render: new $.voodoo.render.TextField() 
            },
            { name: "num_slices",
              render: new $.voodoo.render.TextField(),
              type: $.voodoo.types.integer
            }
        ]
    });

    $.voodoo.VkTable.prototype.as_printable = function() {
        var result = $("<table>");
        result.append(this.$table.find("tr:has(th):eq(0)").clone());

        this.rows().map(function() { result.append(this.as_printable()); });

        return result;
    };

    $.voodoo.VkRow.prototype.as_printable = function() {
        var result = $("<tr>");
        
        this.cells().map(function() { result.append(this.as_printable()); });

        return result;
    };

    $.voodoo.VkCell.prototype.as_printable = function() {
        var result = $("<td>").text(this.isEmpty? "" : this.value() );
        return result;
    };

    $("#{{eid}}_altrender").html(vk{{eid}}.altRender("printable"));

    {% endjscode %}

        This code follows a typical rendering pattern: the table's
        <tt>as_printable</tt> method calls a method of the same name on each
        of its rows, which in turn call a method of the same name on each of
        their cells.  This approach works well in many cases and yields
        generally readable code, but there's no reason you need to stick
        with it.  The only requirement is that, for
        <tt><i>myvktable</i>.altRender(<i>format</i>)</tt> to work, there
        must be an <tt>as_<i>format</i></tt> method on the <tt>VkTable</tt>
        object.

    {% doctest %}
        {% code %}$("#{{eid}}_altrender td:eq(2)").text(){% endcode %}
        {% expect %}"Bob"{% endexpect %}
    {% enddoctest %}

    {% clicktorun %}
    $("#{{eid}}_altrender").html(vk{{eid}}.altRender("printable")) && false
    {% endclicktorun %}

    {% clicktorun %}
    $("#{{eid}}_altrender").text(vk{{eid}}.altRender("json")) && false
    {% endclicktorun %}

{% endexample %}

<h2 class="exp">Paging</h2>
{% example "ex15" %}

Voodookit's paging support works on a simple principle: loading the contents
of another HTML table into the current table.  You can use the same
mechanism to dynamically load a table's contents, or to grow a table, or to
turn pages back and forth.

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Page</th>    <th>Item Number</th>  </tr>
    </table>

    <table id="{{eid}}_staticpage" style="display:none">
      <tr> <td>0</td>    <td>0.1</td>  </tr>
      <tr> <td>0</td>    <td>0.2</td>  </tr>
      <tr> <td>0</td>    <td>0.3</td>  </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo();

    // first, let's load rows from a hidden table that's in the document.
    vk{{eid}}.loadRowsFromTable($("#{{eid}}_staticpage"));

    // in between pages, we'll want to clear the table:
    vk{{eid}}.clear();

    // now we can load multiple pages, even:
    vk{{eid}}.loadRowsFromTable($("#{{eid}}_staticpage"));
    vk{{eid}}.loadRowsFromTable($("#{{eid}}_staticpage"));
    {% endjscode %}

    {% doctest %}
      {% code %}vk{{eid}}.cell(0,0).$td.text(){% endcode %}
      {% expect %}"0"{% endexpect %}
    {% enddoctest %}
    {% doctest %}
      {% code %}vk{{eid}}.cell(4,1).$td.text(){% endcode %}
      {% expect %}"0.2"{% endexpect %}
    {% enddoctest %}

    This loading should be non-destructive to the original table:
    {% doctest %}
      {% code %}$("#{{eid}}_staticpage td:eq(3)").text(){% endcode %}
      {% expect %}"0.2"{% endexpect %}
    {% enddoctest %}

    Try it yourself:
    {% clicktorun %}
    vk{{eid}}.loadRowsFromTable($("#{{eid}}_staticpage"));
    {% endclicktorun %}
    {% clicktorun %}
    vk{{eid}}.clear();
    {% endclicktorun %}

{% endexample %}

<h2 class="exp">Paging with Ajax</h2>
{% example "ex16" %}

    Of course, paging is much more useful when you can load data that's
    <i>not</i> already in your document!

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Page</th>    <th>Item Number</th>  </tr>
    </table>

    <a id="{{eid}}_pagelink" href="{% url vkdoc-tests-example-page-data %}">load next page</a>
    {% endhtmlcode %}


    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo();
    var pageNum = 0;
    var pageUrl = $("#{{eid}}_pagelink").attr("href");

    $("#{{eid}}_pagelink").bind("click", function() {
        vk{{eid}}.loadRowsFromUrl(pageUrl+"?page="+pageNum, {}, function(data, textStatus) { vk{{eid}}.clear(); pageNum++; });
        return false;
    });
    {% endjscode %}

    {% clicktorun %}
    vk{{eid}}.loadRowsFromUrl($("#{{eid}}_pagelink").attr("href"));
    {% endclicktorun %}

{% endexample %}



{% endblock %}
