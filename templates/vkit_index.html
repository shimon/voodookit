{% extends 'base.html' %}
{% load exampletool %}

{% block title %}Voodookit Docs &amp; Demos{% endblock %}

{% block content %}
<h1 style="font-weight:normal">{% include '_myname_voodookit.html' %}: Making &lt;table&gt;s Interactive, Editable, and Awesome</h2>

<p>

  Voodookit is a <a href="http://jquery.com">jQuery</a> plugin designed to
  turn tables of data into sortable, editable, interactive page components.  You
  can use it for something as simple as making an HTML table sortable by any
  column, but its main use is in creating specialized spreadsheet-like apps.

</p>

<p>

  Voodookit was originally built for
  <a href="http://voo2do.com">Voo2do.com</a>, a web-based task management
  system.

</p>


{% comment %}
<p>
  
  Unlike the typical table view widget (example[TODO: link to YUI table
  view), Voodookit is designed to give the developer a great deal of
  flexibility in how tabular data is presented, and what the user can do
  with it.

</p>
{% endcomment %}

<p>
  The full feature set includes:
  (features existing in Voodookit 0.1, to be rewritten as a jQuery plugin)
</p>

<ul>
  
  <li>
    <b>Editing.</b> Users can change cell values, add rows, and delete rows. Changes can be saved to your server (peicemeal or on form submission) or handled by custom javascript.
  </li>

  <li>
    <b>Pagination.</b> Ajax requests can load additional data from your server as needed.
  </li>

  <li>
    <b>Sorting.</b> Re-order table rows based on any column.
  </li>

  <li>
    <b>Templating.</b> Change how cell data is represented using a powerful yet simple template language.
  </li>

  <li>
    <b>Computed Columns.</b> Need to display a <i>time remaining</i> column based on existing <i>total</i> and <i>elapsed</i> column data?  Or just need it calculated for easy reference?  Voodookit makes it easy.
  </li>

  <li>
    <b>Reduction.</b> Compute and display a total, average, or other reduction of an entire column at the bottom of your table, with automatic recalculation if relevant cell values are changed.
  </li>

  <li>
    <b>Data types.</b> Strings, integers, dates, times: tell us what type of data you want in a column, and we'll ensure that it's parsed and serialized properly, And that nobody can get away with typing "banana" in an integer field.  Use the built-in types or create your own.
  </li>

</ul>



<p>Features planned for this new improved version:</p>

<ul>

  <li>
    <b>Filtering.</b> Dynamically show and hide rows based on cell contents.
  </li>

  <li>
    <b>jQuery Events.</b>  Hook into any table events: new rows, edits, recalculation of reductions, etc.
  </li>

  <li>
    <b>Column resizing.</b> If our smart column sizes still aren't quite right, users can drag header edges to resize.
  </li>

  <li>
    <b>Keyboard control.</b> Use customizable key bindings to move a row cursor up and down (like in GMail) and trigger row-specific actions.
  </li>


{% comment %}
  <li>
    <b>.</b>
  </li>
{% endcomment %}

</ul>




<h2>A Better &lt;table&gt;</h2>

{% example "ex1" %}

At its simplest, Voodookit will silently process a table of data:

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Item</th> <th>Quantity</th> </tr>
      <tr> <td>Table</td> <td>1.0</td> </tr>
      <tr> <td>Chair</td> <td>4.0</td> </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo();
    {% endjscode %}

    {% clicktorun %}vk{{eid}}.col(1).sort(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(1).sortReverse(){% endclicktorun %}


    {% doctest %}
      {% code %}vk{{eid}}.numRows(){% endcode %}
      {% expect %}3{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}.numCols(){% endcode %}
      {% expect %}2{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}.numContentRows(){% endcode %}
      {% expect %}2{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}.numHeaderRows(){% endcode %}
      {% expect %}1{% endexpect %}
    {% enddoctest %}

    <p>In addition to getting general information about the table, you can
    query for a specific cell by (row, col) position.  Position coordinates
    are 0-indexed from the top left, and non-content rows are skipped.  The
    return value is an instance of VkCell.</p>

    {% doctest %}
      {% code %}vk{{eid}}.cell(0,1).value(){% endcode %}
      {% expect %}"1.0"{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}.cell(0,1).toString(){% endcode %}
      {% expect %}"1.0"{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}.cell(1,0){% endcode %}
      {% expect %}"Chair"{% endexpect %}
    {% enddoctest %}

    <p> If you want to handle an entire column at once, you can request it by index:
    </p>

    {% doctest %}
      {% code %}vk{{eid}}.col(1).cellValues().join(", "){% endcode %}
      {% expect %}"1.0, 4.0"{% endexpect %}
    {% enddoctest %}

    <p>
      You can even calculate aggregate values for a column using the <tt>reduce</tt> function:
    </p>

    {% doctest %}
      {% code %}vk{{eid}}.col(1).reduce( function(x,y) { return parseFloat(x)+parseFloat(y); } ){% endcode %}
      {% expect %}5.0{% endexpect %}
    {% enddoctest %}

    
    <p>Finally, you can also get Voodookit objects based on a new or already-Voodookit-enabled <tt>&lt;table&gt;</tt> element, or from <tt>tr</tt> or <tt>td</tt> elements within such a table:</p>

    {% doctest %}
      {% code %}$("#{{eid}}").voodoo().constructor.name{% endcode %}
      {% expect %}"VkTable"{% endexpect %}
    {% enddoctest %}
    
    {% doctest %}
      {% code %}$("#{{eid}} tr:last").voodoo().constructor.name{% endcode %}
      {% expect %}"VkRow"{% endexpect %}
    {% enddoctest %}
    
    {% doctest %}
      {% code %}$("#{{eid}} tr:last td:first").voodoo().constructor.name{% endcode %}
      {% expect %}"VkCell"{% endexpect %}
    {% enddoctest %}
    
    
    
{% endexample %}


<h2>Row Addressing</h2>

You can also look up values by row; a <tt>VkRow</tt> object exists for each
row in your table, and can be used to look up a cell's neighbors.

{% example "ex1a" %}

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Item</th>  <th>Price</th>   </tr>
      <tr> <td>Table</td> <td>100</td>     </tr>
      <tr> <td>Chair</td> <td>20.00</td>   </tr>
      <tr> <td>Sofa</td>  <td>1200.00</td> </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            { name: "item" },
            { name: "price" }
        ]
    });
    {% endjscode %}

    {% doctest %}
      {% code %}vk{{eid}}.cell(1, 0).row().cell("price"){% endcode %}
      {% expect %}20.00{% endexpect %}
    {% enddoctest %}

    Similarly, you can get a cell's column, and query for another row's value in the same column:

    {% doctest %}
      {% code %}vk{{eid}}.cell(1, 0).col().cell(0){% endcode %}
      {% expect %}"Table"{% endexpect %}
    {% enddoctest %}


{% endexample %}
  


<h2>Column Data Types</h2>

{% example "ex2" %}

Voodookit's default sorting works fine for alphabetical data. But what if you've got a bunch of actual floating-point numbers?

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Item</th>  <th>Price</th>   </tr>
      <tr> <td>Table</td> <td>100</td>     </tr>
      <tr> <td>Chair</td> <td>20.00</td>   </tr>
      <tr> <td>Sofa</td>  <td>1200.00</td> </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo();
    {% endjscode %}

    {% clicktorun %}vk{{eid}}.col(1).sort(){% endclicktorun %}

    <p>As you can see, this doesn't work so well.  We need to tell Voodookit that the second column contains floating-point numbers.</p>

{% endexample %}



{% example "ex3" %}

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Item</th>  <th>Price</th>   </tr>
      <tr> <td>Table</td> <td>100</td>     </tr>
      <tr> <td>Chair</td> <td>20.00</td>   </tr>
      <tr> <td>Sofa</td>  <td>1200.00</td> </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            { type: $.voodoo.types.string }, // default
            { type: $.voodoo.types.float }
        ]
    });
    {% endjscode %}

    {% clicktorun %}vk{{eid}}.col(1).sort(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(1).sortReverse(){% endclicktorun %}

    <p>Here we're passing a little bit of information to Voodookit about the columns in our table. The <tt>$.voodoo.types.float</tt> object is a Voodookit column type, whose main purpose is to provide a <tt>parseValue</tt> method, converting the table cell's HTML contents into a Javascript value.  For this type, the parseValue method is simply a call to Javascript's built-in <tt>parseFloat</tt> function.</p>

{% endexample %}

<h3>Column Names</h3>

You can also give columns alphanumeric names, and refer to them using these
names instead of their integer identifiers.

{% example "ex3a" %}

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Item</th>  <th>Price</th>   </tr>
      <tr> <td>Table</td> <td>100</td>     </tr>
      <tr> <td>Chair</td> <td>20.00</td>   </tr>
      <tr> <td>Sofa</td>  <td>1200.00</td> </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            { name: "item" },
            { name: "price",
              type: $.voodoo.types.float }
        ]
    });
    {% endjscode %}

    {% doctest %}
      {% code %}vk{{eid}}.col("price").reduce( function(x,y) { return parseFloat(x)+parseFloat(y); } ){% endcode %}
      {% expect %}1320.0{% endexpect %}
    {% enddoctest %}

    {% clicktorun %}vk{{eid}}.col("price").sort(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col("price").sortReverse(){% endclicktorun %}

    As an added bonus, when you provide a column name, Voodookit adds that
    name as a class to all <tt>td</tt> elements in that column:

    
    {% doctest %}
       {% code %}$("#{{eid}} tr:eq(2) td:eq(1)").hasClass("price"){% endcode %}
       {% expect %}true{% endexpect %}
    {% enddoctest %}

{% endexample %}


<h2>Convenience Method for Sorting</h2>

{% example "ex3b" %}

    We often want to allow users to sort the content of a table by clicking
    on <tt>th</tt> elements in the first row.  Voodookit provides a
    convenience method, <tt>makeHeadersSort()</tt>, which easily activates
    this behavior.

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th> <th>Age</th> <th>IQ</th> </tr>
      <tr> <td>Alice</td> <td>2</td> <td>100</td> </tr>
      <tr> <td>Bob</td> <td>1</td> <td>110</td> </tr>
      <tr> <td>Charlie</td> <td>3</td> <td>90</td> </tr>
    </table>

    <style>#{{eid}} th { cursor: pointer; }</style>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo();
    vk{{eid}}.makeHeadersSort();

    // synthesize a click event on the second th, so we can test that
    // the table has been sorted by age.
    $("#{{eid}} tr:first th:eq(1)").trigger("click");
    {% endjscode %}

    {% doctest %}
       {% code %} vk{{eid}}.cell(1,1).value() {% endcode %}
       {% expect %}2{% endexpect %}
    {% enddoctest %}

{% endexample %}



<h2>Date and Time Data</h2>

{% example "ex4" %}

Voodookit also supports date and date+time data types: <tt>DateTime</tt>,
for a date and time, and <tt>Date</tt>, which is a date only.  One way to
express the values for cells of these types is in milliseconds since epoch.
An advantage of this approach is that times can be localized on the client
side, so you don't have to care what time zone your user is in.

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Task</th>                          <th>Deadline (raw)</th> <th>Deadline (date)</th> <th>Deadline (d+t)</th></tr>
      <tr> <td>(3) get approval from client</td>  <td>1245729600000</td>  <td>1245729600000</td>   <td>1245729600000</td> </tr>
      <tr> <td>(1) sketch UI for floobulator</td> <td>1239163200000</td>  <td>1239163200000</td>   <td>1239163200000</td> </tr>
      <tr> <td>(2) send example links to Tim</td> <td>1239336009000</td>  <td>1239336009000</td>   <td>1239336009000</td> </tr>
      <tr> <td>(4) watch a bunch of TV</td>       <td></td>               <td></td>                <td></td>              </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
            cols: [
            { },
            { },
            { type: $.voodoo.types.date },
            { type: $.voodoo.types.dateTime }
        ]
});
    {% endjscode %}

    {% clicktorun %}vk{{eid}}.col(2).sort(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(2).sortReverse(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(2).sortReverseBlanksLast(){% endclicktorun %}

{% endexample %}



<h2>Events</h2>

{% example "ex5" %}

Want to add an <tt>odd</tt> class to the odd rows? Or respond to changes in
the table's sort order?  Voodookit generates events you can register for:
<ul>

  <li><b><tt>vkRowScan</tt></b> &mdash; generated when a content row (a
  <tt>tr</tt> element that contains one or more <tt>td</tt> elements) is
  handled by Voo2do: on first review of the table content, and on subsequent
  changes to row position (sorting).  In this event's <tt>data</tt> hash:
  <ul>

      <li><tt>rowIndex</tt>: an integer indicating this row's position among
      all content rows in the table, starting from 0.</li>

      <li><tt>vkRow</tt>: the VkRow object for this table row.</li>

    </ul>
  </li>

  <li><b><tt>vkChange</tt></b> &mdash; generated when the value of a cell is
  changed.  Initially triggered on a <tt>td</tt>, and bubbles up the
  document so you can also bind to a <tt>table</tt> and get this event.
  Because you may be interested in changes within a column, the
  <tt>vkChange</tt> event is also fired by the corresponding column, which
  provides a <tt>bind</tt> method for this purpose. In this event's <tt>data</tt> hash:
  <ul>
    <li><tt>oldValue</tt>: the cell's previous value.</li>
    <li><tt>cell</tt>: the VkCell object for the affected cell.  You can get the current (new) value by calling <tt>cell.value()</tt>.</li>
  </ul>
  </li>

</ul>

These events are triggered on the underlying <tt>tr</tt> elements, so you
can listen for and react to them in the typical jQuery way.

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>First Name</th>  <th>Last Name</th> </tr>
      <tr> <td>Bob</td>         <td>Jones</td>     </tr>
      <tr> <td>Alice</td>       <td>Smith</td>     </tr>
      <tr> <td>Charlie</td>     <td>Williams</td>  </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    $("#{{eid}} tr").bind("vkRowScan", function(e, data) {
        var isOdd = data["rowIndex"] % 2;
        $(this).css({ "background-color": isOdd? "skyblue": "lightgreen",
                      "font-weight": isOdd? "bold": "normal"
                    });
    });
    var vk{{eid}} = $("#{{eid}}").voodoo();
    {% endjscode %}

    {% clicktorun %}vk{{eid}}.col(0).sort(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(1).sort(){% endclicktorun %}

    {% doctest %}
      {% code %}$("#{{eid}} tr:eq(2)").css("font-weight"){% endcode %}
      {% expect %}"bold"{% endexpect %}
    {% enddoctest %}
{% endexample %}



<h2>Renderers</h2>

<p>In the examples so far, the values displayed in our HTML tables have
simply been the default, stringified version of the cell's value.  For a
<tt>$.voodoo.types.date</tt> column, we see something like "06/23/2009".
But what if you want your cell displayed in different format?</p>

<p>That's where <b>renderers</b> come in.  Renderers determine how to
display the values of cells in HTML.  The renderer has access to the cell's
<tt>VkCell</tt> object, allowing the rendering behavior to be based on the
cell's value as well as its row, column, and table.</p>

<p>Voodookit includes the following built-in renderers. <b>These are classes
and should be instantiated using <tt>new</tt>.</b> You can also build
your own renderer&mdash;more on that later.</p>

<ul>
  <li><tt>$.voodoo.render.<b>String</b></tt></li>
  <li><tt>$.voodoo.render.<b>HtmlString</b></tt></li>
  <li><tt>$.voodoo.render.<b>FloatHours</b> *TODO*</tt></li>
  <li><tt>$.voodoo.render.<b>Currency</b> *TODO*</tt></li>
  <li><tt>$.voodoo.render.<b>LocaleDate</b></tt></li>
  <li><tt>$.voodoo.render.<b>LocateDateTime</b></tt></li>
</ul>

<p>Many of these renderers accept options that configure how they
behave. Options can be passed in as an associative array parameter.  Two
options are supported by all renderers: <tt>default</tt>, which specifies
the result to return when rendering an empty cell, and <tt>defaultValue</tt>
which does something slightly different: it treats empty cells as having the
given value &mdash; useful if you want to apply the same logic to generate the HTML for empty cells.</p>


{% example "ex6" %}

Let's see how the <tt>default</tt> setting works using the String renderer.

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th>    <th>Pizza Choices</th> </tr>
      <tr> <td>Bob</td>     <td>Pepperoni</td>     </tr>
      <tr> <td>Alice</td>   <td> </td>             </tr>
      <tr> <td>Charlie</td> <td></td>              </tr>
    </table>

    <p>Part 2:</p>

    <table id="{{eid}}_2">
      <tr> <th>Name</th>    <th>Pizza Choices</th> </tr>
      <tr> <td>David</td>   <td></td>              </tr>
      <tr> <td>Eliza</td>   <td><b>peppers</b>--this is bad, should just be HTML</td>              </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            {},
            { render: new $.voodoo.render.String({"default":"<i>unknown</i>"}) }
        ]
    });

    // on the second table, let's use the defaultValue option instead:
    var vk{{eid}}_2 = $("#{{eid}}_2").voodoo({
        cols: [
            {},
            { render: new $.voodoo.render.String({"defaultValue":"<i>unknown</i>"}) }
        ]
    });
    {% endjscode %}

    {% doctest %}
      {% code %}$("#{{eid}} tr:last td:last").html(){% endcode %}
      {% expect %}"<i>unknown</i>"{% endexpect %}
    {% enddoctest %}

    Note that in our HTML, the value for Alice's pizza choices is a single
    space character&mdash; not considered empty by Voodookit. Hence it is
    rendered as a space:

    {% doctest %}
      {% code %}"["+$("#{{eid}} tr:eq(2) td:last").html()+"]"{% endcode %}
      {% expect %}"[ ]"{% endexpect %}
    {% enddoctest %}

    In the second table, we used the <tt>defaultValue</tt> option instead of
    <tt>default</tt>.  What does this mean?

    {% doctest %}
      {% code %}$("#{{eid}}_2 tr:eq(1) td:last").html(){% endcode %}
      {% expect %}"&lt;i&gt;unknown&lt;/i&gt;"{% endexpect %}
    {% enddoctest %}

    {% comment %}
      {% clicktorun %}$("#{{eid}}_2 tr:eq(2) td:last").html(){% endclicktorun %}
      {% clicktorun %}$("#{{eid}}_2 tr:eq(2) td:last").text(){% endclicktorun %}
    {% endcomment %}

{% endexample %}


<h3>Numeric Renderers</h3>

<h3>Renderers with Editing</h3>

Often, you'll want to let users not only view the data in a table cell,
but also edit that data.  Voodookit's editable renderers make this easy,
by providing a representation of the cell value as an editable HTML form
widget, whose <tt>change</tt> event triggers a value change on the
corresponding <tt>vkCell</tt>.  That means the changes are more than
just skin deep&mdash;you can instantly re-sort, or use event listeners
to react to <tt>vkValueChange</tt> events.

<h4>Text and checkbox fields</h4>

{% example "ex7" %}


    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th>    <th>Pizza Choices</th> <th>Paid?</th> </tr>
      <tr> <td>Alice</td>   <td>Artichokes</td>    <td>1</td>  </tr>
      <tr> <td>Bob</td>     <td>Pepperoni</td>     <td>0</td> </tr>
      <tr> <td>Charlie</td> <td></td>              <td></td>      </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            {},
            { render: new $.voodoo.render.TextField() },
            { type: $.voodoo.types.boolean,
              render: new $.voodoo.render.CheckboxField() }
        ]
    });
    {% endjscode %}

    {% clicktorun %}vk{{eid}}.col(0).sort(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(0).sortReverse(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(1).sort(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(1).sortReverse(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(2).sort(){% endclicktorun %}
    {% clicktorun %}vk{{eid}}.col(2).sortReverse(){% endclicktorun %}

{% endexample %}

<h4>Dealing with Edits</h4>

{% example "ex8" %}

    When a cell's value is changed, the vkChange event fires. This event
    bubbles up from the changed <tt>td</tt> element, so you can listen for
    it on a particular cell or on the whole table.

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th>    <th>Pizza Choices</th> <th>Slices Eaten</th> </tr>
      <tr> <td>Alice</td>   <td>Artichokes</td>    <td>1</td>  </tr>
      <tr> <td>Bob</td>     <td>Pepperoni</td>     <td>0</td> </tr>
      <tr> <td>Charlie</td> <td></td>              <td>0</td>      </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            {},
            { render: new $.voodoo.render.TextField(),
              name: "pizza_choices"
            },
            { type: $.voodoo.types.integer,
              name: "numslices",
              render: new $.voodoo.render.TextField() }
        ]
    });

    var vk{{eid}}_gotTableEvent = false;
    var vk{{eid}}_gotRowEvent = false;
    var vk{{eid}}_gotColumnEvent = false;

    $("#{{eid}}").bind("vkChange", function() {
        vk{{eid}}_gotTableEvent = true;
    });

    $("#{{eid}} tr:eq(2)").bind("vkChange", function() {
        vk{{eid}}_gotRowEvent = true;
    });

    vk{{eid}}.col("pizza_choices").bind("vkChange", function() {
        vk{{eid}}_gotColumnEvent = true;
    });

    vk{{eid}}.cell(1,1).value("Sausage");
    {% endjscode %}

    {% doctest %}
      {% code %}vk{{eid}}_gotTableEvent{% endcode %}
      {% expect %}true{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}_gotRowEvent{% endcode %}
      {% expect %}true{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}_gotColumnEvent{% endcode %}
      {% expect %}true{% endexpect %}
    {% enddoctest %}

    <p>The vkChange event is also used by renderers to update the rendered
    value when a cell's value is changed; try this increment operation to
    see how that works:</p>

    {% clicktorun %}vk{{eid}}.cell(1,2).value( 1+vk{{eid}}.cell(1,2).value() ){% endclicktorun %}

{% endexample %}



<h2>Adding Rows</h2>

{% example "ex9" %}

 In addition to changing data in existing rows, you can add rows to a
 Voodookit-enabled table.  You can do this in two ways:

 <ol>

   <li>use a standard jQuery method on the table, like
   <tt>$("#mytable").append("<tr><td>...</td></tr>")</tt> followed by a call
   to <tt>$("#mytable").voodoo.findNewRows()</tt>, or</li>

   <li>use the built-in <tt>$("#mytable").voodoo.append()</tt> method, which
   does the same thing.</li>

 </ol>

 When content is added this way, any new rows are processed and rendered
 based on the parameters first sent to Voodookit on initialization of the
 parent table. A <tt>vkRowScan</tt> event is also generated for each new row.

    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th>    <th>Pizza Choices</th> <th>Slices Eaten</th> </tr>
      <tr> <td>Alice</td>   <td>Artichokes</td>    <td>1</td>  </tr>
      <tr> <td>Bob</td>     <td>Pepperoni</td>     <td>0</td> </tr>
      <tr> <td>Charlie</td> <td>Chicken</td>       <td>0</td>      </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}}_newRowText = null;
    var vk{{eid}}_newRowIndex = null;

    $("#{{eid}}").bind("vkRowScan", function(e,data) {
        vk{{eid}}_newRowText = data.vkRow.cell(0).value().toString();
        vk{{eid}}_newRowIndex = data.rowIndex;
    });

    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            {},
            { render: new $.voodoo.render.TextField() },
            { render: new $.voodoo.render.TextField() }
        ]
    });

    $("#{{eid}}").voodoo().append("<tr><td>Dave</td><td>Olives</td><td>1</td></tr>");
    {% endjscode %}


    {% doctest %}
      {% code %}vk{{eid}}_newRowIndex{% endcode %}
      {% expect %}3{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}_newRowText{% endcode %}
      {% expect %}"Dave"{% endexpect %}
    {% enddoctest %}

    So to recap, there's the two-step method: add table content however you want and then call <tt>findNewRows</tt>:

    {% clicktorun %}$("#{{eid}}").append("<tr><td>Ed</td><td>Spinach</td><td>2</td></tr>"){% endclicktorun %}

    {% clicktorun %}$("#{{eid}}").voodoo().findNewRows(){% endclicktorun %}

    Or the <tt>append</tt> method built into Voodookit's <tt>VkTable</tt> class, which returns the <tt>VkTable</tt> object so it's chainable:

    {% clicktorun %}$("#{{eid}}").voodoo().append("<tr style=display:none><td>Ed</td><td>Spinach</td><td>2</td></tr>").$table.find("tr:last").fadeIn("slow") && false{% endclicktorun %}

{% endexample %}


<h2>Deleting Rows</h2>

{% example "ex10" %}

  <p>Add too many rows? Maybe you want to delete some. You can do this with
  standard jQuery/DOM methods if you wish: just <tt>.remove()</tt> a
  <tt>tr</tt> and all VoodooKit methods (row counts, positional cell
  coordinates, etc.) will keep working just fine, because VoodooKit treats
  the DOM (plus jQuery <tt>.data</tt>) as the primary underlying data
  structure whenever possible.</p>

  <p>However, in most cases it is preferable to use the
  <tt>VkRow.delete()</tt> method, which will not only remove the appropriate
  <tt>tr</tt> from the table, but also generate some useful events:
  </p>
  
  <ul>
    <li><b><tt>vkRowDelete</tt></b> on the row about to be deleted, while the <tt>VkRow</tt> object is still accessible.</li>
    <li><b><tt>vkRowScan</tt></b> on all <i>remaining</i> rows in the table.</li>  </ul>


    {% htmlcode %}
    <table id="{{eid}}">
      <tr> <th>Name</th>    <th>Slices Eaten</th>  <th>Delete?</th> </tr>
      <tr> <td>Alice</td>   <td>1</td>             <td></td>        </tr>
      <tr> <td>Bob</td>     <td>0</td>             <td></td>        </tr>
      <tr> <td>Charlie</td> <td>0</td>             <td></td>        </tr>
    </table>
    {% endhtmlcode %}

    {% jscode %}
    var vk{{eid}}_name_deleted;
    var vk{{eid}}_num_scans_per_name = {};

    $("#{{eid}}").bind("vkRowDelete", function(e) {
        vk{{eid}}_name_deleted = $(e.target).voodoo().cell(0);
    });

    $("#{{eid}} tr").bind("vkRowScan", function(e, data) {
        var r = data.vkRow;
        var name = r.cell(0).value();

        if(!vk{{eid}}_num_scans_per_name[ name ]) {
            vk{{eid}}_num_scans_per_name[ name ] = 0;
        }

        vk{{eid}}_num_scans_per_name[ name ]++;
    });

    var vk{{eid}} = $("#{{eid}}").voodoo({
        cols: [
            {},
            { render: new $.voodoo.render.TextField() },
            { render: new $.voodoo.render.HtmlString({default:"<a href='#' class='del'>del</a>"}) }
        ]
    });

    $("#{{eid}} a.del").live("click", function() {
        $(this).parents("tr").voodoo().delete();
        return false;
    });

    $("#{{eid}} a.del:first").trigger("click");
    {% endjscode %}

    {% doctest %}
      {% code %}vk{{eid}}.numContentRows(){% endcode %}
      {% expect %}2{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}_name_deleted{% endcode %}
      {% expect %}"Alice"{% endexpect %}
    {% enddoctest %}

    The row we deleted should have 1 row scan, from the initial load:

    {% doctest %}
      {% code %}vk{{eid}}_num_scans_per_name["Alice"]{% endcode %}
      {% expect %}1{% endexpect %}
    {% enddoctest %}

    Remaining rows should have 2 row scans, one from initial load and one
    after the deletion of the Alice row:

    {% doctest %}
      {% code %}vk{{eid}}_num_scans_per_name["Bob"]{% endcode %}
      {% expect %}2{% endexpect %}
    {% enddoctest %}

    {% doctest %}
      {% code %}vk{{eid}}_num_scans_per_name["Charlie"]{% endcode %}
      {% expect %}2{% endexpect %}
    {% enddoctest %}


    In some cases, you might not want to immediately remove the deleted
    <tt>tr</tt> from the document.  For example, you might want to animate
    the removal effect.  You can do this by calling <tt>prepToDelete</tt>
    instead of <tt>delete</tt>&mdash; <tt>prepToDelete</tt> will ready the
    row for deletion and send the appropriate events, and like
    <tt>delete</tt> will return a jQuery object wrapping the relevant
    <tt>tr</tt>.  But unlike <tt>delete</tt>, <tt>prepToDelete</tt> counts
    on you to make a final call to <tt>remove</tt> the row when you're done.
    (It is important that you actually do remove the row from its containing
    <tt>table</tt>; until you complete that step, the VkTable object's
    state, such as the result of <tt>numRows()</tt>, will be inconsistent
    with the events that have been generated.)

    {% clicktorun %}
    $("#{{eid}} tr:eq(1)").voodoo().prepDelete().fadeOut(function(){ $(this).remove(); }) && false;
    {% endclicktorun %}
    

{% endexample %}


{% endblock %}
